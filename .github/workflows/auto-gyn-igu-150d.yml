name: Auto GYN-IGU 150d <=500

on:
  schedule:
    - cron: "0 */2 * * *"   # roda a cada 2 horas no clock do GitHub (UTC)
  workflow_dispatch: {}      # permite rodar manualmente também

permissions:
  contents: write

jobs:
  auto-gyn-igu:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: true
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install deps (if package.json exists)
        run: |
          if [ -f package.json ]; then
            npm ci || npm i
          else
            echo "Sem package.json — pulando npm install"
          fi

      - name: Install Playwright Chromium
        run: npx -y playwright@1.56.1 install --with-deps chromium

      # 1) CAPTURA VAIDEPROMO GYN -> IGU PARA 150 DIAS
      - name: Capture Vaidepromo GYN-IGU (150 dias)
        shell: bash
        env:
          ORIGIN: GYN
          DEST: IGU
        run: |
          set -e
          START=$(TZ=America/Sao_Paulo date +%F)
          DAYS=150
          DELAY=3500   # ms
          DEBUG=0

          echo "Iniciando captura fixa: $ORIGIN->$DEST | start=$START | days=$DAYS | delay_ms=$DELAY"

          for ((i=0;i<DAYS;i++)); do
            D=$(date -d "$START + $i day" +%F)
            echo "==> Dia $((i+1))/$DAYS: $D"
            ORIGIN="$ORIGIN" DEST="$DEST" DATE="$D" DEBUG="$DEBUG" node scripts/capture.js \
              || echo "Falha no dia $D, continuando..."
            if [ $i -lt $((DAYS-1)) ]; then
              sleep $((DELAY/1000))
            fi
          done

      # 2) GERA SNAPSHOT ÚNICO EM public/YYYY-MM-DD_GYN-IGU.csv
      - name: Gerar snapshot único em public/YYYY-MM-DD_GYN-IGU.csv
        env:
          ROUTE_FROM: GYN
          ROUTE_TO:   IGU
          TZ: America/Sao_Paulo
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const path = require('path');

          function ensureDir(dir){ fs.mkdirSync(dir, { recursive:true }); }

          function listResultsFiles(root="data"){
            const out=[];
            function walk(d){
              if(!fs.existsSync(d)) return;
              for(const ent of fs.readdirSync(d, { withFileTypes:true })){
                const full = path.join(d, ent.name);
                if(ent.isDirectory()) walk(full);
                else if(ent.isFile() && ent.name.toLowerCase() === 'results.csv') out.push(full);
              }
            }
            walk(root);
            out.sort((a,b)=>a.localeCompare(b));
            return out;
          }

          // Detecta separador na 1ª linha (prioriza ;), suporta aspas opcionais
          function splitSmart(line, sepHint){
            const sep = sepHint || (line.includes(';') ? ';' : ',');
            const out=[]; let cur=''; let inQ=false;
            for (let i=0;i<line.length;i++){
              const ch=line[i];
              if (ch === '"'){
                if (inQ && line[i+1] === '"'){ cur+='"'; i++; }
                else inQ = !inQ;
              } else if (ch === sep && !inQ){
                out.push(cur); cur='';
              } else {
                cur += ch;
              }
            }
            out.push(cur);
            return out.map(s=>s.trim());
          }

          function parseCSV(text){
            const lines = text.split(/\r?\n/).filter(l=>l.trim().length>0);
            if(!lines.length) return {header:[], rows:[]};
            const headerRaw = lines[0];
            const sep = headerRaw.includes(';') ? ';' : (headerRaw.includes(',') ? ',' : ';');
            const header = splitSmart(headerRaw, sep).map(h=>String(h).trim().toLowerCase());
            const rows = lines.slice(1).map(l => {
              const arr = splitSmart(l, sep);
              if (arr.length !== header.length) return null;
              const obj = Object.fromEntries(header.map((h,i)=>[h, arr[i]]));
              return obj;
            }).filter(Boolean);
            return { header, rows };
          }

          function normalizePrice(v){
            if(v==null) return null;
            let s = String(v).trim().replace(/[^\d.,-]/g, '');
            const lastDot = s.lastIndexOf('.');
            const lastCom = s.lastIndexOf(',');
            const decIdx  = Math.max(lastDot, lastCom);
            if (decIdx >= 0) {
              const decSep = s[decIdx];
              const thousandSep = decSep === '.' ? ',' : '.';
              s = s.replace(new RegExp('\\' + thousandSep, 'g'), '');
              if (decSep === ',') s = s.replace(',', '.');
            }
            const n = Number.parseFloat(s);
            return Number.isFinite(n) ? Number(n.toFixed(2)) : null;
          }

          function todayStr(tz='America/Sao_Paulo'){
            const parts = new Intl.DateTimeFormat('en-CA', {
              timeZone: tz, year:'numeric', month:'2-digit', day:'2-digit'
            }).formatToParts(new Date());
            const bag = Object.fromEntries(parts.filter(p=>p.type!=='literal').map(p=>[p.type,p.value]));
            return `${bag.year}-${bag.month}-${bag.day}`;
          }

          const FROM = (process.env.ROUTE_FROM||'GYN').toUpperCase().trim().replace(/\s+/g,'');
          const TO   = (process.env.ROUTE_TO||'IGU').toUpperCase().trim().replace(/\s+/g,'');
          const ROUTE = `${FROM}-${TO}`;

          const all = listResultsFiles('data');
          const norm = s => s.replace(/\\/g,'/').toUpperCase();
          const re = new RegExp(`_${FROM}\\s*-\\s*${TO}(/|_)`); // aceita espaços ao redor do hífen
          const filesRoute = all.filter(fp => re.test(norm(fp)));

          const files = filesRoute.length ? filesRoute : all; // fallback para "todos"
          console.log(`[snapshot] results.csv encontrados: total=${all.length} | rota=${filesRoute.length}`);

          const byDate = new Map(); // date -> [prices]

          function push(map, date, price){
            if(!date || price==null) return;
            if(!map.has(date)) map.set(date, []);
            map.get(date).push(price);
          }

          for(const fp of files){
            try{
              const txt = fs.readFileSync(fp,'utf8');
              const { rows } = parseCSV(txt);
              for(const r of rows){
                const bag = Object.fromEntries(Object.entries(r).map(([k,v])=>[k.toLowerCase(), v]));
                const date = (bag.date || '').trim();
                const priceRaw = bag.price_brl ?? bag['price brl'] ?? bag.price ?? bag.preco_brl ?? bag.valor_brl ?? bag.valor;
                const price = normalizePrice(priceRaw);
                push(byDate, date, price);
              }
            }catch(e){
              console.error('Falhou em', fp, e.message);
            }
          }

          const dates = Array.from(byDate.keys()).filter(Boolean).sort();
          for(const d of dates){
            byDate.set(d, Array.from(new Set(byDate.get(d))).sort((a,b)=>a-b));
          }

          ensureDir('public');
          const lines = ['"date";"price_brl"'];
          let count = 0;
          for(let i=0;i<dates.length;i++){
            const d = dates[i];
            for(const p of byDate.get(d)){
              lines.push(`"${d}";"${p.toFixed(2)}"`);
              count++;
            }
            if(i<dates.length-1) lines.push('');
          }

          const snapshot = `${todayStr()}_${ROUTE}.csv`;
          const safeName = snapshot.replace(/\s+/g,''); // remove espaços do nome
          fs.writeFileSync(path.join('public', safeName), lines.join('\n')+'\n', 'utf8');
          console.log(`[snapshot] criado public/${safeName} | dias=${dates.length} | linhas=${count}`);

          if (count === 0){
            console.error('Nenhuma linha gerada. Verifique se há data/…/results.csv com colunas date e price_brl.');
            process.exit(1);
          }
          NODE

      # 3) FILTRA SNAPSHOT PARA PREÇO <= 500,00 E SALVA EM resumo/
      - name: Filtrar snapshot para <= 500 BRL em resumo/
        shell: bash
        run: |
          set -e
          LAST=$(ls -1t public/*.csv | head -n 1)
          echo "Usando snapshot: $LAST"
          node filter-by-price.cjs "$LAST" "500"

      # 4) LIMPA data/ (APAGA TUDO APÓS CRIAR O ARQUIVO FINAL)
      - name: Limpar pasta data/ (mantendo .gitkeep)
        shell: bash
        run: |
          if [ -d data ]; then
            find data -mindepth 1 -maxdepth 1 ! -name '.gitkeep' -exec rm -rf {} +
            echo "Conteúdo de data/ apagado (exceto .gitkeep)."
          else
            echo "Pasta data/ não existe, nada para apagar."
          fi

      # 5) COMMIT & PUSH (public + resumo + estado de data/)
      - name: Commit & push resultados
        shell: bash
        run: |
          git config user.name  "${GITHUB_ACTOR}"
          git config user.email "${GITHUB_ACTOR}@users.noreply.github.com"
          git add public/*.csv resumo/*.csv data || true
          if git diff --cached --quiet; then
            echo "Sem mudanças para commitar."
          else
            git commit -m "auto: GYN-IGU 150d snapshot <=500"
            git push || echo "Não foi possível dar push (verifique permissões do token)"
          fi